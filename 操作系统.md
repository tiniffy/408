# 计算机系统概述

## 操作系统的概念

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219171250489.png" alt="image-20221219171250489" style="zoom:50%;" />

操作系统（Operating System，OS）是指控制和管理整个计算机系统的==硬件和软件==资源；并合理地组织调度计算机的工作和资源的分配，以==提供给用户和其他软件方面的接口环境==，它是计算机系统中最基本的==系统软件==

1. 操作系统是系统资源的管理者
2. 向上提供方便易用的服务
3. 最接近硬件的一层软件

## 操作系统的功能和目标

1. 操作系统作为==系统资源的管理者==（这些资源包括软件、硬件、文件等），需要提供什么功能？
2. 操作系统作为==用户与计算机硬件之间的接口==，要为其上层的用户、应用程序提供简单易用的服务，需要实现什么功能？
3. 操作系统作为==最接近硬件的层次==，需要在纯硬件的基础上实现什么样的功能？

### 操作系统作为系统资源的管理者

**功能**

1. 处理机管理
2. 存储器管理
3. 文件管理
4. 设备管理

**目标**

安全、高效

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221218135239716.png" alt="image-20221218135239716" style="zoom:50%;" />

### 操作系统作为用户与计算机硬件之间的接口

**功能**

1. 命令接口：允许用户==直接使用==，包括脱机命令接口和联机命令接口
2. 程序接口：允许用户通过程序==间接使用==
3. GUI：现代操作系统中最流行==图形用户接口==

* 上面三个统称为用户接口

**目标**

方便用户使用

####  命令接口

**联机命令接口**（交互式命令接口）

用户说一句，系统做一句

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221218140017053.png" alt="image-20221218140017053" style="zoom:50%;" />

**脱机命令接口**（批处理命令接口）
用户说一堆，系统做一堆

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221218140248546.png" alt="image-20221218140248546" style="zoom:50%;" />

#### 程序接口（系统调用）

允许用户通过程序间接使用，由一组==系统调用==组成

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221218140525894.png" alt="image-20221218140525894" style="zoom:50%;" />

* 系统调用=系统调用命令=广义指令

#### GUI

Graphical User Interface，图形用户界面
用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221218140933606.png" alt="image-20221218140933606" style="zoom:50%;" />

### 操作系统作为最接近硬件的层次

需要提供的功能和目标：实现对硬件机器的拓展

* 没有任何软件支持的计算机称为==裸机==。在裸机上安装的操作系统，可以提供资源管理器和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器
* 通常把覆盖了软件的机器称为==扩充机器==，又称为==虚拟机==

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221218141615342.png" alt="image-20221218141615342" style="zoom:50%;" />

## 操作系统的四个特征

1. 并发
2. 共享
3. 虚拟
4. 异步

* 并发和共享时两个最基本的特征，二者互为存在条件

### 并发

指两个或多个事件在==同一时间间隔内发生==。==这些事件宏观上时同时发生的，但微观上时交替发生的==

* 易混概念：并行指两个或多个事件在同一时刻同时发生

==操作系统的并发性==指计算机系统中同时存在多个运行着的程序

一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序==并发（交替）==执行（这些程序微观上是交替执行的，但宏观上看起来就像在同时执行）

事实上，操作系统就是伴随着”多道程序技术“而出现的。因此，==操作系统和程序并发是一起诞生的==

当今的计算机，一般都是多核CPU，比如Intel第八代i3处理器就是4核CPU，这意味着同一时刻可以有4个程序并行执行，但是操作系统的并发性依然必不可少，当代人使用计算机绝对有4个以上的程序需要同时工作

### 共享

共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用

1. 互斥共享

系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源

2. 同时共享

系统中的某些资源，允许一个时间段内由多个进程"同时"对它们进行访问，所谓”同时“是指宏观上的，微观上，这些进程可能是交替地堆该资源进行访问的（即分时共享）

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221218143537828.png" alt="image-20221218143537828" style="zoom:50%;" />

### 虚拟

指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的

1. 空分复用技术（如虚拟存储技术）
2. 时分复用技术（如虚拟存储器）

* 显然，==如果失去了并发性，就谈不上虚拟性了==

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221218144054582.png" alt="image-20221218144054582" style="zoom:50%;" />

### 异步

异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前迈进，这就是进程的异步性

* 显然，只有系统拥有并发性，才有可能导致异步性

## 操作系统的发展和分类

* 理解各阶段的优点和缺点，各阶段的主要优点都是解决了上一阶段的主要缺点

### 手工操作阶段

**主要缺点**

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221218150430085.png" alt="image-20221218150430085" style="zoom:50%;" />

用户独占全机、人机速度矛盾导致资源利用率低
（用户独占全机指一个时间段内该机器只能为一个用户服务）

### 批处理阶段

1. 单道批处理系统
2. 多道批处理系统（操作系统开始出现）

**单道批处理系统**

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221218151143091.png" alt="image-20221218151143091" style="zoom:50%;" />

引入==脱机输入/输出技术（用磁带完成）==，并==监督程序（操作系统的雏形）==负责控制作业的输入、输出

1. 自动性

   在顺利的情况下，磁盘上的一批作业能自动地逐个运行，而无需人工干预

2. 顺序性

   先调入内存的作业先完成

3. 单道性

   内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行

**主要优点**

缓解了一定的人机速度矛盾，资源利用率有所提升

**主要缺点**

==内存中仅能有一道程序运行==，只有该程序运行结束之后才能调入下一道程序。==CPU有大量的时间在空闲等待I/O完成。==资源利用率依然很低

**多道批处理系统（操作系统正式诞生）**

1. 多道

   计算机内存中同时存放多道相互独立的程序

2. 宏观上并行

   同时进入系统的多道程序都处于运行过程中

3. 微观上串行

   内存中的多道升序轮流占有CPU，交替执行

每次往内存中输入多道程序。==操作系统正式诞生，并引入了中断技术，由操作系统负责管理这些程序的运行。各个程序并发执行==

**主要优点**

多道程序==并发==执行，==共享==计算机资源。==资源利用率大幅提升==，CPU和其他资源保持”忙碌“状态 ，系统吞吐量增大

* 为什么说多道批处理系统能使资源利用率大幅提升？

| ![image-20221218152059904](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221218152059904.png) | ![image-20221218152115769](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221218152115769.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

**主要缺点**

用户响应时间长，==没有人机交互功能==（用户提交自己的作业之后只能等待计算机处理完成，中间不能控制自己的作业执行）

### 分时操作系统

计算机以==时间片==为单位==轮流为各个用户/作业服务==，各个用户可通过终端与计算机进行交互

**主要优点**

用户请求可以被即时响应，==解决了人机交互问题==。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在

**主要缺点**

==不能优先处理一些紧急任务==。操作系统对各个用户/作业都是完全公平的，循环地为每个用户。作业服务一个时间片，不区分任务的紧急性

### 实时操作系统

**主要优点**

能够优先相应一些紧急任务，某些紧急任务不需时间排队

在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且==要在严格的时限内处理完事件==。

* 主要特点：及时性、可靠性

1. 硬实时操作系统
必须在绝对严格的规定的事件内完成处理
2. 软实时操作系统
能接受偶尔违反时间约定

### 网络操作系统

是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传递等功能，==实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。==（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用）

### 分布式操作系统

主要特调是==分布性和并行性==。系统中的各台计算机地位相同，==任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务==

### 个人计算机操作系统

如：Windowsxp、MacOS，方便个人使用

## OS的运行机制

* 程序是如何运行的？

代码经过编译器编译变成机器指令（==二进制==）
“指令”就是处理器（CPU）能识别、执行的最基本命令
程序运行的过程其实就是CPU执行一条一条的机器指令的过程

* 一条高级语言代码翻译过来可能会对应多条机器指令

* Linux,Windows,MacOS的“小黑框”中使用的命令其实交互式命令接口，和指令不同，指令是二进制的

### 运行机制

#### 两种程序

1. 内核程序

  苹果有一帮人负责实现操作系统，他们写的是内核程序。有很多内核程序组成了操作系统内核，或简称内核。

  内核是操作系统中最重要的部分，也是最接近硬件的部分。甚至可以说，一个操作系统只要有内核就够了（eg：Docker->仅需Linux内核）

  操作系统的功能未必都在内核中，如图形化用户界面GUI

2. 应用程序
  我们普通程序员写的程序就是应用程序。为了保证系统能安全运行,普通应用程序只能执行非特权指令,运行在用户态。

#### 两种指令

1. 特权指令

   操作系统内核作为管理者，有时会让CPU执行一些特权指令，如：内存清零指令。这些指令影响重大，只允许管理者——即操作系统内核来使用

2. 非特权指令

​		应用程序只能使用非特权指令，如：加法指令、减法指令等

#### 两种处理器状态

* 在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行指令前能判断指令类型，但是怎么区分此时运行的是内核程序or应用程序呢？

  用CPU的状态区分

CPU有两种状态：内核态和用户态。

* CPU中有一个==程序状态寄存器（PSW）==，其中有个二进制位，1表示内核态，0表示用户态

1. 用户态（目态）
   CPU只能执行非特权指令
2. 内核态（管态、核心态）
   特权指令、非特权指令都可执行

### 内核态、用户态的切换

1. 内核态->用户态，执行一条==特权指令==——==修改PSW==的标志位为用户态，这个动作意味着操作系统将主动让出CPU使用权
2. 用户态->内核态，由==中断==引发，==硬件自动完成变态过程==，触发中断信号意味着操作系统将强行夺回CPU的使用权

* 除了非法使用特权指令之外，还有很多事件会触发中断信号。一个共性是，==但凡需要操作系统介入的地方，都会触发中断信号==

eg：

1. 刚开机时，CPU为==内核态==，操作系统内核程序先上CPU运行
2. 开机完成后，用户可以启动某个程序
3. 操作系统内核程序会在合适的的时候让出CPU，让该程序在CPU上运行。操作系统内核会在让出CPU之前，用一条特权指令把PSW的标志位设置为用户态（内核态->用户态）
4. 此时，如果有人在应用程序中植入了一条特权指令，企图破坏系统
5. CPU发现接下来要执行的这条指令是特权指令，但是自己又处于用户态
6. 这个非法事件会产生一个==中断信号==，==CPU检测到中断信号后==，会立即变为==核心态==（硬件自动完成），并停止运行当前的应用程序，转而运行处理中断信号的内核程序
7. “中断“操作是操作系统再次夺回CPU的控制权
8. 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序

### 中断和异常

#### 中断的作用

CPU上会运行两种程序，一种是操作系统内核程序，一种是应用程序，在合适的情况下，操作系统会把CPU的使用权主动让给应用程序（第二章进程管理）。中断会使CPU由用户态变为内核态，是操作系统重新夺回对CPU的控制权

* ==中断是让操作系统内核夺回CPU使用权的唯一途径==，如果没有中断机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序，也就不存在并发

#### 中断的类型

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219200226226.png" alt="image-20221219200226226" style="zoom:50%;" />

**内中断（异常、例外）**

与当前执行的指令有关，中断信号来源于CPU内部
eg：试图在用户态下执行特权指令、执行除法指令时发现除数为0、陷入指令

* 陷入指令

有时应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令——陷入指令，该指令会引发一个==内部中断==信号。执行陷入指令，意味着应用程序主动地将CPU控制权还给操作系统内核。==系统调用就是通过陷入指令完成的==

**外中断（中断）**

与当前执行的指令无关，中断信号来源于CPU外部

* 每一条指令结束，CPU都会例行检查是否有外部中断信号

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219200138448.png" alt="image-20221219200138448" style="zoom:50%;" />

eg：时钟中断、I/O中断

#### 中断的基本原理

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219200451982.png" alt="image-20221219200451982" style="zoom:50%;" />

### 系统调用

系统调用是操作系统提供给应用程序（程序员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，==应用程序可以通过系统调用来请求获得操作系统内核的服务==

* 系统调用与库函数的区别

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219202053377.png" alt="image-20221219202053377" style="zoom:50%;" />

* 为什么系统调用是必须的？

  由操作系统内核对共享资源进行统一的管理，并向上提供系统调用，用户进程想要使用这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理

* 什么功能要用到系统调用？

  应用程序通过系统调用请求操作系统的服务。二系统中的各种共享资源都由操作系统内核统一掌管，因此==凡是与共享资源有关的操作（如：存储分配、I/O操作、文件管理等）==，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作

  系统调用按功能分类：

  1. 设备管理
  2. 文件管理
  3. 进程控制
  4. 进程通信
  5. 内存管理

#### 系统调用的过程

1. 传参
2. 陷入指令（trap/访管）
3. 由操作系统内核程序处理系统调用请求
4. 返回应用程序

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219202908779.png" alt="image-20221219202908779" style="zoom:50%;" />

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219202928525.png" alt="image-20221219202928525" style="zoom:50%;" />

## 操作系统结构

### 操作系统的内核

==内核==是计算机上配置的底层==软件==，是操作系统最基本、最核心的部分

实现操作系统内核功能的那些程序就是内核程序<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219182443340.png" alt="image-20221219182443340" style="zoom:50%;" />

1. 时钟管理

   实现计时功能

2. 中断处理

   负责实现中断机制

3. 原语
   是一种特殊的程序

   处于操作系统最底层，是最接近硬件的部分

   这种程序的运行具有原子性——（其运行只能是一气呵成，不能中断）

   运行时间短，调用频繁

4. 对系统资源进行管理的功能

   进程管理、存储器管理、设备管理

   * 有的操作系统不把这部分功能归为内核功能。也就是说，不同的操作系统，对内核功能的划分可能并不一样

* 时钟管理、终端橱窗、原语是与硬件关联较紧密的模块

### 内核的分类

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219183139769.png" alt="image-20221219183139769" style="zoom:50%;" />

1. 宏内核（大内核/单内核）
2. 微内核
3. 分层结构
4. 模块化
5. 外核

#### 宏内核和微内核

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219210807096.png" alt="image-20221219210807096" style="zoom:50%;" />

**大内核**

将操作系统的主要功能模块都作为系统内核，运行在核心态

**优点**：高性能

**缺点**：内核代码庞大，结构混乱，难以维护

**微内核**

只把最基本的功能保留在内核

**优点**：内核功能少，结构清晰，方便维护

**缺点**：需要频繁地在核心态和用户态之间切换，性能低

#### 分层结构

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219211259855.png" alt="image-20221219211259855" style="zoom:50%;" />

#### 模块化

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219211353965.png" alt="image-20221219211353965" style="zoom:50%;" />

#### 外核

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219211428813.png" alt="image-20221219211428813" style="zoom:50%;" />

#### 总结

![image-20221219211537453](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219211537453.png)

## 操作系统引导（BOOT）

开机运行操作系统

![image-20221219212837727](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219212837727.png)

## 虚拟机

使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machime,VM），每个虚拟机器都可以独立运行一个操作系统

* 同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor（VMM）/Hypervisor

![image-20221219215428982](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219215428982.png)

![image-20221219215459568](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221219215459568.png)

# 进程和线程

## 进程（Process）

在多道程序环境下，允许多个程序并发执行，此时他们将失去封闭性，并且具有并发性和不可再现性的特征，为此引入了进程的概念，以便更好地描述和控制程序地并发执行。

从不同的角度，进程有不同的定义，比较典型的定义有:

1. 进程是程序的一次执行过程
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3. 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位
4. 进程是进程实体的运行过程，是系统进行资源调配的调度的一个独立单位

* 区别进程和程序

  程序是静态的，就是存放在磁盘里的可执行文件。如：qq.exe

  进程是动态的，是程序的一次执行过程，如：可同时启动多次QQ程序

  同一程序多次执行会对应多个进程

通常用户进程被建立后，随着进程进程的正常或不正常结束而==撤销==

### 进程的组成

1. PCB
2. 程序段
3. 数据段

进程的信息都被保存在了一个数据结构$PCB$(Process Control Block)中，即==进程控制块==，系统利用$PCB$来描述进程的基本情况和运行状态， 进而控制和管理进程。

* ==$PCB$是进程存在的唯一标志==
* $PCB$是给操作系统用的，程序段、数据段是给进程自己用的

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221155122246.png" alt="image-20221221155122246" style="zoom:50%;" />

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221160030554.png" alt="image-20221221160030554" style="zoom:50%;" />

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221155323807.png" alt="image-20221221155323807" style="zoom:50%;" />

### 进程的特征

1. 动态性
2. 并发性
3. 独立性
4. 异步性
5. 结构性

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221160143003.png" alt="image-20221221160143003" style="zoom:50%;" />

### 进程的状态与转换

**进程的状态**

1. 运行态
2. 就绪态
3. 阻塞态（等待态）
4. 创建态
5. 终止态

* 运行态、就绪态、阻塞态是==三种基本状态==

![image-20221221160653868](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221160653868.png)

![image-20221221160733441](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221160733441.png)

![image-20221221160742954](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221160742954.png)

![image-20221221160752365](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221160752365.png)

* 注意区别就绪态和阻塞态（等待态）

  就绪态是指进程仅缺少处理器，只要获得处理机资源就能立即运行

  阻塞态是指进程需要其他资源（除了处理机）

**进程状态的转换**

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221161209223.png" alt="image-20221221161209223" style="zoom:50%;" />

* 一个进程从运行态变成阻塞态是主动的行为，而从阻塞态变成就绪态是被动的行为，需要其他相关进程的协助

### 进程的组织

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221161649499.png" alt="image-20221221161649499" style="zoom:50%;" />

![image-20221221161715267](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221161715267.png)

### 进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态等功能。简单来说，进程控制就是要实现进程状态转换

**那么怎么实现进程控制**？

==用原语实现==

原语的特点是执行期间不允许被中断，它是不可分割的一个基本单位

**为什么要用原语**

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221162504020.png" alt="image-20221221162504020" style="zoom:50%;" />

显然，实现进程控制（状态转换）必须把以上步骤都做完，做一半显然会产生错误

**如何实现原语的“原子性”**

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221162730909.png" alt="image-20221221162730909" style="zoom:50%;" />

正常情况下，CPU每执行完一条指令都会例行检查知否有中断信号处理。那么我们就在指令中增加一组关中断指令和开中断指令，那么在这一段指令区间内，就没有中断，执行过程一气呵成，这就是原语

### 进程控制相关的原语

1. 进程创建
2. 进程终止
3. 进程的阻塞（Block）和唤醒（Wakeup）
4. 进程的切换

Block原语和Wakeup原语是一对作用刚好相反的原语，必须成对使用

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221163336467.png" alt="image-20221221163336467"  />

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221163353236.png" alt="image-20221221163353236"  />

![image-20221221163450351](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221163450351.png)

![image-20221221163500649](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221221163500649.png)

### 进程通信（IPC）

Inter-Process Communication.

进程通信是指进程之间进行信息交换。

* 为什么进程通信需要操作系统提供支持？

  进程是分配系统资源的单位（包括内存地址空间），因此==各进程拥有的内存地址空间相互独立==，为了保证安全，==一个进程不能直接访问另一个进程的地址空间==

$PV$操作是低级通信方式，高级通信方式主要分以下三类：

1. 共享存储
2. 消息传递
3. 管道通信

#### 共享存储

1. 基于数据结构的共享（低级）
2. 基于存储区的共享（高级）

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221222195956100.png" alt="image-20221222195956100" style="zoom:50%;" />

#### 消息传递

在消息传递系统中，进程间的数据交换==以格式化的消息（Message）为单位==。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。==进程通信通过系统提供的发送消息和接收消息两个原语进行数据交换==

==这种方式隐藏了通信实现细节，使通信过程对用户透明，简化了通信程序的设计，是当前应用最广泛的进程通信机制==

在微内核操作系统中，微内核与服务器之间的通信就采用了消息传递机制。由于该机制能很友好地支持多处理机系统、分布式系统和计算机网络，因此也成为这些领域最主要的通信工具

1. 直接通信方式
2. 间接通信方式

#### 管道通信

”管道“是一个特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区。在Linux中该缓冲区的大小为4KB。

<img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221222201541038.png" alt="image-20221222201541038" style="zoom:50%;" />

## 线程

引入进程的目的是更好地使多道程序并发执行，提高资源利用率和吞吐量；而引入线程的目的则是减小程序在并发执行时所付出的时间开销，提高操作系统的并发性能

线程最直接的理解就是“轻量级进程”，==线程是一个基本的CPU执行单元，也是程序执行流的最小单位。进程只作为出CPU外的系统资源的分配单元==。由于一个进程内部有多个线程，若程序的切换发生在同一个进程内部，则只需要很小的时间开销

### 进程和线程的比较

1. 调度

   在传统的操作系统中，拥有资源和独立调度的基本单位都是进程，每次调度都需要进行上下文切换，开销较大。在引入线程的操作系统中，线程是独立调度的基本单位。在同一个进程中，线程的切换不会引起进程切换。但从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换

2. 并发性

   线程提高了系统并发行

3. 拥有资源

   ==进程是系统中拥有资源的基本单位，而线程不拥有系统资源（仅有一点必不可少、能保证独立运行的资源）==

4. 独立性

   每个进程都有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问，某进程中的线程对其他进程不可见。

5. 系统开销

   线程切换小，进程切换大

6. 支持多处理机系统

   对于传统单线程进程，不管有多少处理机，进程只能运行在一个处理机上。对于多线程进程，可以将进程中的多个线程分配到多个处理机上运行

### 线程的状态与切换

与进程一样，各线程之间也存在共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。相应地，线程在运行时也具有下面三种基本状态：

1. 执行态
2. 就绪态
3. 阻塞态

线程这三种基本状态之间的转换和进程基本上是一样的

### 线程的组织与控制

* 线程控制块

  与进程类似，系统也为每个线程配置一个线程控制块$TCB$，用于记录控制和管理线程的信息

### 线程的实现方式

1. 用户级线程$ULT$(User_Level Thread)
2. 内核级线程$KLT$(Kernel_level Thread)

**用户级线程**（$ULT$）

![image-20221222192857051](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221222192857051.png)

**内核级线程**（$KLT$）

![image-20221222193012296](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221222193012296.png)

**组合方式**

![image-20221222193258594](C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221222193258594.png)

* 线程库（thread library）

  在线程的实现方式中，提到了通过线程库来创建和管理线程。线程库是为程序员提供创建和管理线程的$API$,实现线程库的主要方式有两种

  1. 在用户空间提供一个没有内核支持的库。调用库内的一个函数只导致用户空间中的一个本地函数的调用
  2. 实现由操作系统直接支持的内核级的一个库。调用库中的一个$API$函数通常会导致对内核的系统调用

###  多线程模型

1. 多对一模型

   <img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221222212538775.png" alt="image-20221222212538775" style="zoom:50%;" />

2. 一对一模型

   <img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221222212457369.png" alt="image-20221222212457369" style="zoom:50%;" />

3. 多对多模型

   <img src="C:\Users\zhangweihang\AppData\Roaming\Typora\typora-user-images\image-20221222212519958.png" alt="image-20221222212519958" style="zoom:50%;" />

## 补充

* ==并发进程失去封闭性==，是指并发进程共享变量，其执行结果与速度有关。

  程序封闭性是指进程执行的结果只取决于进程本身，不受外界影响。也就是说，进程在执行过程中不管是不停顿地运行，还是走走停停，进程的执行速度都不会改变它的执行结果。失去封闭性后，不同速度下的执行结果不同

* C语言编写程序在使用内存时一般分为三个段，他们一般是正文段（代码和赋值数据段）、数据堆段（动态分配的存储区）、数据栈段（临时变量）

